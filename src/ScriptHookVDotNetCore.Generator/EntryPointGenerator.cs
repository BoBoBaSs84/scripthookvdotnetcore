using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ScriptHookVDotNetCore.Generator;

namespace ScriptHookVDotNet.Generator
{

    [Generator]
    public class EntryPointGenerator : SymbolPopulator, ISourceGenerator
    {

        public void Execute(GeneratorExecutionContext context)
        {
            try
            {

                Populate(context);

                var scripts = GenerateScriptsRegister();

                if (string.IsNullOrEmpty(scripts)) return;

                var init = EntryPointExists("OnInit") ? "" : InitCode;
                var unload = EntryPointExists("OnUnload") ? "" : UnloadCode;
                var keyboard = EntryPointExists("OnKeyboard") ? "" : KeyboardCode;
                var tick = EntryPointExists("OnTick") ? "" : TickCode;
                string source = $@"// <auto-generated/>
{Globals}
using System.Runtime.InteropServices;
using GTA;

namespace SHVDN;

/// <summary>
/// Template for generating AOT entrypoints
/// </summary>
public static unsafe partial class EntryPoint
{{
    static void ModuleSetup()
    {{
        {scripts}
    }}

    {init}
    {unload}
    {keyboard}
    {tick}
}}
";
                context.AddSource("EntryPoint.g.cs", source);
            }
            catch (Exception ex)
            {
#if DEBUG
                // MessageBox(default, ex.ToString(), "ScriptHookVDotNet source generator error", default);
#else
                throw;
#endif
            }
        }
         bool EntryPointExists(string entry)
        {
            return AllMethods.SelectMany(method => method.GetAttributes()).Any(attri =>
            attri.AttributeClass.ToString() == "System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute"
            && attri.NamedArguments.Any(x => x.Key == "EntryPoint" && x.Value.Value.ToString() == entry));
        }
        string GenerateScriptsRegister()
        {
            var source = "GTA.Script script;\n";
            var scripts = AllClasses.Where(x => x.TypeKind == TypeKind.Class && !x.IsAbstract && x.IsSubClassOf("GTA.Script"));
            if (!scripts.Any()) return null;
            foreach (var script in scripts)
            {
                if (script.GetAttributes().Any(x => x.AttributeClass.ToString() == "GTA.ScriptAttributes" && x.NamedArguments.Any(x => x.Key == "NoDefaultInstance" && ((bool)x.Value.Value)))) continue;
                var fullName = script.ToString();
                source += $"script = new {fullName}();";
                source += $"Core.RegisterScript(script);\n";
                source += $"GTA.Console.RegisterCommands(typeof({fullName}));\n";
                source += $"GTA.Console.RegisterCommands(typeof({fullName}), script);\n";
            }
            return source;
        }
        public void Initialize(GeneratorInitializationContext context)
        {
        }
        #region Codes

        const string InitCode = @"
    [UnmanagedCallersOnly(EntryPoint = ""OnInit"")]
    public static void OnInit(HMODULE module)
    {
        try
        {
            Core.OnInit(module);
            ModuleSetup();
        }
        catch (Exception ex)
        {
            MessageBoxA(default, ex.ToString(), ""Module initialization error"", MB_OK);
            throw; // Crash the process
        }
    }";
        const string UnloadCode = @"/// <summary>
    /// Called prior to module unload
    /// </summary>
    /// <param name=""module""></param>
    [UnmanagedCallersOnly(EntryPoint = ""OnUnload"")]
    public static void OnUnload(HMODULE module)
    {
        try
        {
            Core.OnUnload(module);
        }
        catch(Exception ex)
        {
            Logger.Error(""Module unload error: "" + ex.ToString());
        }
    }";
        const string KeyboardCode = @"[UnmanagedCallersOnly(EntryPoint = ""OnKeyboard"")]
    public static void OnKeyboard(DWORD key, ushort repeats, bool scanCode, bool isExtended, bool isWithAlt,
        bool wasDownBefore, bool isUpNow)
    {
        try
        {
            Core.DoKeyEvent(
            key,
            !isUpNow,
            (GetAsyncKeyState(VK_CONTROL) & 0x8000) != 0,
            (GetAsyncKeyState(VK_SHIFT) & 0x8000) != 0,
            isWithAlt);
        }
        catch(Exception ex)
        {
            Logger.Error(""Keyboard event error: "" + ex.ToString());
        }
    }";
        const string TickCode = @"
    [UnmanagedCallersOnly(EntryPoint = ""OnTick"")]
    public static void OnTick(LPVOID currentFiber)
    {
        try
        {
           Core.DoTick(currentFiber);
        }
        catch(Exception ex)
        {
            Logger.Error(""Tick error: "" + ex.ToString());
        }
    }";
        const string Globals = $@"
global using System;
global using System.IO;
global using DWORD = System.Int32;
global using DWORD64 = System.Int64;
global using HANDLE = System.IntPtr;
global using LPVOID = System.IntPtr;
global using HINSTANCE = System.IntPtr;
global using HMODULE = System.IntPtr;
global using static SHVDN.Globals;
global using static SHVDN.PInvoke;";
        #endregion
    }
}
